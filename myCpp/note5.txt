继承   
protected  保护继承  子类中可以访问对外不可以访问。
尽量不适用protected  一面父子间耦合性太强。

->专项作用,返回某个变量的地址。

先构造父类然后按照定义顺序创建成员对象。
指向构造函数构造体,构造函数默认调用父类构造函数(不会传参)。如果需要传参则需要在初始化类表中用父类名指示。

子类顶一顶函数会隐藏弗雷有同名的函数。及时参数不同也不会构成函数重载。如果确实需要调用父类的函数,应用弗雷明限定  类名::函数
父子类只会隐藏不会重载名。

多态
处于效率不会自动识别多态。
父类中声明虚函数,则子类中自动声明为虚函数。子类中可以覆盖这个函数,也自动成为虚函数。覆盖要求函数名相同参数表相同
返回类型一致(如父类中返回父类指针子类中也可以返回父类指针)。
运行时程序就是块内存。010010000011
传一个地址给this指针。
一般用虚函数表实现。对应增加4个字节(类大小)。
每一个变量至少占用一个字节。否则就无地址或者共用地址。
string 指针指向动态内存。
dynamic_cast<>必需有多态
dynamic_cast<子类*> (父类型指针)	成功返回子类地址否则NULL(常用)
dynamic_cast<引用> (父类型对象)		父类转子类(一般用于初始化子类引用或当场使用,失败抛异常)
typeid    //include<typeinfo>
typeid(var)  变量类型名	类似于sizeof 
typeid(typename)
typeid(a).name();
对虚函数typeid用于多态 进行类型识别
gcc中虚函数表在最先4个字节。
纯虚函数:无函数体  用 =0;取代函数体。
抽象类不可定义对象,总是父类。
通过父类指针释放子类对象时默认调用父类析构函数,因此应声明为虚函数,析构不可为纯虚函数,每次释放对象时都调用。
构造函数不可为虚函数,调用构造函数时对象不存在,调用虚函数时要使用虚构指针。而构造时才会产生虚函数表。运行时
根据对象确定调用哪个函数。

string类
string(const string &s);
string(const char *s);
string(int n , char c);
运算符:<<,>>,=,+,+=,[],a+(i),比较运算符 < , <= ,>,>=,==,!=
长度: size() length() empty() resize(newsize , charfill)
转换成c风格:c_str()'\0' data()不保证带'\0' cpoy(char *to , int num)
substr()