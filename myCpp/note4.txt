编译器在编译时自动分开类定义和实现。先看声明再看函数体的内容,故成员可以定义在使用的函数之后。
先扫描类的声明再扫描类的实现。


class A{
	const A& x
	use(){//x不可更改
		//use可以更改类的成员。
	}
//use有权更改类的成员,虽然并未更改。故报错。
};
int size() const{}
const对象调用的成员函数也要求其不会修改对象的成员数据。在参数表之后用const来修饰。表示不修改当前对象的成员值。  不能修改thi

mutable关键字。易变的  表示const对象内部允许修改成员。

编程语言--------> 内存


运算符重载;运算符其实是函数。运算符需要参数,有结果。函数也需要参数又返回值。
cpp中运算符都是函数。运算符函数代替运算符。

NA* operator&(){
	return NULL;//取不到地址。
}
友元类中所有的成员函数均是友元函数。
第一个操作数为当前对象则不需要传递第一个操作数 当做成员函数即可。通过this访问第一个操作数。
只能用作成员函数的  [] () =x  x--> type
动态成员----->   复制构造 = 析构 三个函数
圆括号运算符  参数个数不定  operator()(参数)  支持()重载的又称函数对象。

type operator double(){}类型转换运算符。不指定返回类型则报错。只能是成员函数。

const成员只能调用const成员函数,其内部this是const A* const   而普通成员函数的this是A * co
nst
const A* const this
A* const  this       &
this  地址
变     不变

this指向当前对象

new  delete  
先new再构造   先析构在delete
new A[] 是烦恼会的前4个字节值为元素个数。
后++用遥远 遥远类型为int   不用则为前置++
operator++(int)
不允许重载的运算符:    .  .*  ?:  :: # typeid   sizeof

不应创建新的运算符  不应改变操作数的个数
