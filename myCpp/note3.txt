编译器可以自动产生构造函数和析构函数。
定义全局对象可以在main函数执行之前完成某些操作。

变量创建与释放。
	全局变量  main函数之前创建 main函数之后释放
	静态局部变量  第一次执行时创建 main函数返回后释放。
	普通局部变量  每次执行时创建  超出作用范围后释放
	临时结果           临时创建 完成后当场释放
	动态变量	         执行new创建   执行delete释放

编译器在对象未超出其作用范围时无法获取是否已经无法使用。
匿名对象用完即释放。

析构函数   对象释放是自动调用 函数名为~类名  系统自动调用 程序员没机会调用
析构函数无参  手动调用可以传参  系统调用无法传参
无法重载  一般为public
只释放内存 系统回收内存

new时 用delete是才会调用析构函数。
对象本省占用的空间会在超出作用范围或使用delete后自动释放。如果对象分配了额外的资源则可以在析构函数中释放那些额外的资源。

类名(参数)

class B{};
class A{
	B b;	//传参时限制性B的构造。
};

传参时会发生id哦那个类型转换。
explicit关键字禁止匿名对象自动类型转换。
拷贝构造:
A (A a);  //传参时递归的调用复制构造函数。
A (A& a);//正常复制构造。

编译器默认产生拷贝构造函数。复制相应的成员。
若有指针进入则释放相应的成员时会delete两次。从而导致内存错误。

重写拷贝构造函数。 让每个指针成员指向一片动态内存,并把相应的数据复制到相应的内存里面去。
对成员指针不能直接复制,而是让其指向一块动态内存,然后复制动态内存中的数据。


零初始化  类型名()
inita=int();
初始化列表:参数之后函数体之前,以冒号开头。若干对成员(初值)逗号隔开。如果成员是常量或者引用则只可以用初始化列表。

静态成员:类名::成员变量
没有this  类外初始化。
匿名对象 没有名字 同样可以调用构造函数和析构函数。编译器会对其进行优化。只有一个参数的匿名对象可以看成类型转换。编译器自动完成。
若要禁止编译器这样做则可以哦使用explicit关键字。

